<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State Pattern - תבניות עיצוב בפייתון</title>
    <link rel="stylesheet" href="../css/styles.css">
 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Prism.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <!-- Prism.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <!-- Prism.js Python Language Support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script></head>
<body>
    <div class="side-nav-container">
        <nav class="side-nav">
            <!-- הסיידבר יוטען כאן באופן דינמי -->
        </nav>
    </div>

    <main class="main-content">
        <header class="rtl-container">
            <h1 class="flex-center">
                <i class="fas fa-toggle-on icon"></i>
                State Pattern
            </h1>
            <a href="../index.html" class="flex-center">
                <i class="fas fa-arrow-right icon"></i>
                חזרה לדף הבית
            </a>
        </header>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-info-circle icon"></i>
                מהי תבנית State?
            </h2>
            <p>תבנית State היא תבנית עיצוב התנהגותית המאפשרת לאובייקט לשנות את התנהגותו כאשר מצבו הפנימי משתנה. התבנית מאפשרת לאובייקט להיראות כאילו הוא משנה את המחלקה שלו.</p>
            
            <h3>הסבר למתחילים:</h3>
            <p>דמיינו שיש לכם מנורה עם שלושה מצבים: כבויה, דולקת, ומהבהבת. במקום לכתוב קוד מורכב שמטפל בכל המצבים, אתם יכולים להשתמש בתבנית State כדי להפוך כל מצב לאובייקט נפרד. זה מאפשר לכם להוסיף מצבים חדשים בקלות, ולשנות את ההתנהגות של המנורה בהתאם למצב הנוכחי.</p>
            
            <h3>הסבר למתקדמים:</h3>
            <p>התבנית מיישמת את עקרון ה-Open/Closed Principle על ידי הפרדת המצבים למחלקות נפרדות. זה מאפשר הוספה של מצבים חדשים ללא צורך בשינוי הקוד הקיים, ומאפשר שינוי דינמי של ההתנהגות בהתאם למצב הנוכחי.</p>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-question-circle icon"></i>
                מתי להשתמש בתבנית?
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>כאשר יש צורך לשנות את ההתנהגות של אובייקט בהתאם למצבו</li>
                <li>כאשר יש מספר רב של תנאים שמשפיעים על ההתנהגות</li>
                <li>כאשר יש צורך להוסיף מצבים חדשים בקלות</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>כאשר יש צורך לשנות את ההתנהגות של אובייקט בהתאם למצבו</li>
                <li>כאשר יש מספר רב של תנאים שמשפיעים על ההתנהגות</li>
                <li>כאשר יש צורך להוסיף מצבים חדשים בקלות</li>
                <li>כאשר יש צורך לשמור על עקרון ה-Open/Closed Principle</li>
                <li>כאשר יש צורך להפחית את הצימוד בין המחלקות</li>
                <li>כאשר יש צורך לאפשר הרחבה של המערכת עם מצבים חדשים</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-sitemap icon"></i>
                מבנה התבנית
            </h2>
            <h3>הסבר בסיסי:</h3>
            <p>התבנית מורכבת משלושה חלקים עיקריים:</p>
            <ul>
                <li><strong>Context</strong> - האובייקט שמשנה את התנהגותו בהתאם למצב</li>
                <li><strong>State</strong> - הממשק שמגדיר את הפעולות המשותפות לכל המצבים</li>
                <li><strong>ConcreteState</strong> - המימוש של הממשק</li>
            </ul>

            <h3>הסבר מתקדם:</h3>
            <p>התבנית מורכבת מהמרכיבים הבאים:</p>
            <ul>
                <li><strong>Context</strong> - האובייקט שמשנה את התנהגותו בהתאם למצב</li>
                <li><strong>State</strong> - הממשק שמגדיר את הפעולות המשותפות לכל המצבים</li>
                <li><strong>ConcreteState</strong> - המימוש של הממשק</li>
                <li><strong>Client</strong> - האובייקט שיוצר את ה-Context ומגדיר את המצב ההתחלתי</li>
            </ul>

            <h3>היחסים בין המרכיבים:</h3>
            <ul>
                <li>Context מחזיק מצב נוכחי</li>
                <li>State מגדיר את הממשק</li>
                <li>ConcreteState מיישם את הממשק</li>
                <li>Client יוצר את ה-Context ומגדיר את המצב ההתחלתי</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-code icon"></i>
                דוגמה בסיסית
            </h2>
            <h3>הסבר למתחילים:</h3>
            <p>בדוגמה הבאה, אנחנו יוצרים מנורה עם שלושה מצבים: כבויה, דולקת, ומהבהבת. במקום לכתוב קוד מורכב שמטפל בכל המצבים, אנחנו משתמשים בתבנית State כדי להפוך כל מצב לאובייקט נפרד.</p>

            <h3>הסבר למתקדמים:</h3>
            <p>הדוגמה מדגימה את השימוש ב-State Pattern להפרדת המצבים למחלקות נפרדות. הממשק מגדיר את הפעולות הבסיסיות, והמימושים הספציפיים מספקים את הפונקציונליות.</p>

            <pre><code class="language-python">from abc import ABC, abstractmethod

class State(ABC):
    @abstractmethod
    def turn_on(self) -> None:
        pass
    
    @abstractmethod
    def turn_off(self) -> None:
        pass
    
    @abstractmethod
    def blink(self) -> None:
        pass

class Light:
    def __init__(self):
        self._state = OffState()
    
    def set_state(self, state: State) -> None:
        self._state = state
    
    def turn_on(self) -> None:
        self._state.turn_on()
    
    def turn_off(self) -> None:
        self._state.turn_off()
    
    def blink(self) -> None:
        self._state.blink()

class OffState(State):
    def turn_on(self) -> None:
        print("המנורה דולקת")
        self._context.set_state(OnState())
    
    def turn_off(self) -> None:
        print("המנורה כבר כבויה")
    
    def blink(self) -> None:
        print("המנורה מהבהבת")
        self._context.set_state(BlinkState())

class OnState(State):
    def turn_on(self) -> None:
        print("המנורה כבר דולקת")
    
    def turn_off(self) -> None:
        print("המנורה כבויה")
        self._context.set_state(OffState())
    
    def blink(self) -> None:
        print("המנורה מהבהבת")
        self._context.set_state(BlinkState())

class BlinkState(State):
    def turn_on(self) -> None:
        print("המנורה דולקת")
        self._context.set_state(OnState())
    
    def turn_off(self) -> None:
        print("המנורה כבויה")
        self._context.set_state(OffState())
    
    def blink(self) -> None:
        print("המנורה כבר מהבהבת")

# שימוש
if __name__ == "__main__":
    # יצירת מנורה
    light = Light()
    
    # הפעלת פקודות
    light.turn_on()  # המנורה דולקת
    light.blink()  # המנורה מהבהבת
    light.turn_off()  # המנורה כבויה
    light.turn_off()  # המנורה כבר כבויה</code></pre>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-laptop-code icon"></i>
                דוגמה מעשית - מערכת ניהול הזמנות
            </h2>
            <h3>הסבר למתחילים:</h3>
            <p>בדוגמה זו, אנחנו יוצרים מערכת ניהול הזמנות. ההזמנה יכולה להיות במצבים שונים: חדשה, מאושרת, בתהליך, או הושלמה. במקום לכתוב קוד מורכב שמטפל בכל המצבים, אנחנו משתמשים בתבנית State כדי להפוך כל מצב לאובייקט נפרד.</p>

            <h3>הסבר למתקדמים:</h3>
            <p>הדוגמה מדגימה את השימוש ב-State Pattern להפרדת המצבים למחלקות נפרדות. הממשק מגדיר את הפעולות הבסיסיות, והמימושים הספציפיים מספקים את הפונקציונליות.</p>

            <pre><code class="language-python">from abc import ABC, abstractmethod
from typing import List

class OrderState(ABC):
    @abstractmethod
    def approve(self) -> None:
        pass
    
    @abstractmethod
    def process(self) -> None:
        pass
    
    @abstractmethod
    def complete(self) -> None:
        pass
    
    @abstractmethod
    def cancel(self) -> None:
        pass

class Order:
    def __init__(self, items: List[str]):
        self._items = items
        self._state = NewState()
    
    def set_state(self, state: OrderState) -> None:
        self._state = state
    
    def approve(self) -> None:
        self._state.approve()
    
    def process(self) -> None:
        self._state.process()
    
    def complete(self) -> None:
        self._state.complete()
    
    def cancel(self) -> None:
        self._state.cancel()

class NewState(OrderState):
    def approve(self) -> None:
        print("ההזמנה אושרה")
        self._context.set_state(ApprovedState())
    
    def process(self) -> None:
        print("לא ניתן לעבד הזמנה חדשה")
    
    def complete(self) -> None:
        print("לא ניתן להשלים הזמנה חדשה")
    
    def cancel(self) -> None:
        print("ההזמנה בוטלה")
        self._context.set_state(CancelledState())

class ApprovedState(OrderState):
    def approve(self) -> None:
        print("ההזמנה כבר מאושרת")
    
    def process(self) -> None:
        print("ההזמנה בתהליך")
        self._context.set_state(ProcessingState())
    
    def complete(self) -> None:
        print("לא ניתן להשלים הזמנה מאושרת")
    
    def cancel(self) -> None:
        print("ההזמנה בוטלה")
        self._context.set_state(CancelledState())

class ProcessingState(OrderState):
    def approve(self) -> None:
        print("לא ניתן לאשר הזמנה בתהליך")
    
    def process(self) -> None:
        print("ההזמנה כבר בתהליך")
    
    def complete(self) -> None:
        print("ההזמנה הושלמה")
        self._context.set_state(CompletedState())
    
    def cancel(self) -> None:
        print("ההזמנה בוטלה")
        self._context.set_state(CancelledState())

class CompletedState(OrderState):
    def approve(self) -> None:
        print("לא ניתן לאשר הזמנה שהושלמה")
    
    def process(self) -> None:
        print("לא ניתן לעבד הזמנה שהושלמה")
    
    def complete(self) -> None:
        print("ההזמנה כבר הושלמה")
    
    def cancel(self) -> None:
        print("לא ניתן לבטל הזמנה שהושלמה")

class CancelledState(OrderState):
    def approve(self) -> None:
        print("לא ניתן לאשר הזמנה שבוטלה")
    
    def process(self) -> None:
        print("לא ניתן לעבד הזמנה שבוטלה")
    
    def complete(self) -> None:
        print("לא ניתן להשלים הזמנה שבוטלה")
    
    def cancel(self) -> None:
        print("ההזמנה כבר בוטלה")

# שימוש
if __name__ == "__main__":
    # יצירת הזמנה
    order = Order(["מוצר 1", "מוצר 2"])
    
    # הפעלת פקודות
    order.approve()  # ההזמנה אושרה
    order.process()  # ההזמנה בתהליך
    order.complete()  # ההזמנה הושלמה
    order.cancel()  # לא ניתן לבטל הזמנה שהושלמה</code></pre>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-plus-circle icon"></i>
                יתרונות
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>מאפשרת הפרדה בין המצבים</li>
                <li>מאפשרת הוספת מצבים חדשים בקלות</li>
                <li>מאפשרת שינוי דינמי של ההתנהגות</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>מאפשרת הפרדה בין המצבים</li>
                <li>מאפשרת הוספת מצבים חדשים בקלות</li>
                <li>מאפשרת שינוי דינמי של ההתנהגות</li>
                <li>מאפשרת שמירה על עקרון ה-Open/Closed Principle</li>
                <li>מאפשרת הפחתת הצימוד בין המחלקות</li>
                <li>מאפשרת הרחבה של המערכת עם מצבים חדשים</li>
                <li>מאפשרת ניהול טוב יותר של המצבים</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-minus-circle icon"></i>
                חסרונות
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>עלולה להקשות על הבנת הקוד</li>
                <li>עלולה ליצור מספר רב של מחלקות</li>
                <li>עלולה להקשות על ניהול הקוד</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>עלולה להקשות על הבנת הקוד</li>
                <li>עלולה ליצור מספר רב של מחלקות</li>
                <li>עלולה להקשות על ניהול הקוד</li>
                <li>עלולה להקשות על בדיקות (Testing)</li>
                <li>עלולה להקשות על ניהול גרסאות</li>
                <li>עלולה להקשות על ניהול תלויות</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-exclamation-triangle icon"></i>
                מלכודות נפוצות
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>אי-הקפדה על יצירת ממשק פשוט</li>
                <li>אי-הקפדה על שימוש נכון במצבים</li>
                <li>אי-הקפדה על ניהול תלויות</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>אי-הקפדה על יצירת ממשק פשוט</li>
                <li>אי-הקפדה על שימוש נכון במצבים</li>
                <li>אי-הקפדה על ניהול תלויות</li>
                <li>אי-הקפדה על ניהול גרסאות</li>
                <li>אי-הקפדה על בדיקות (Testing)</li>
                <li>אי-הקפדה על ניהול זיכרון</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-balance-scale icon"></i>
                השוואה לתבניות אחרות
            </h2>
            <h3>למתחילים:</h3>
            <table>
                <tr>
                    <th>תבנית</th>
                    <th>הבדל</th>
                </tr>
                <tr>
                    <td>Strategy</td>
                    <td>מתמקדת באלגוריתמים, בעוד State מתמקדת במצבים</td>
                </tr>
                <tr>
                    <td>Command</td>
                    <td>מתמקדת בפעולות, בעוד State מתמקדת במצבים</td>
                </tr>
            </table>

            <h3>למתקדמים:</h3>
            <table>
                <tr>
                    <th>תבנית</th>
                    <th>הבדל</th>
                </tr>
                <tr>
                    <td>Strategy</td>
                    <td>מתמקדת באלגוריתמים, בעוד State מתמקדת במצבים</td>
                </tr>
                <tr>
                    <td>Command</td>
                    <td>מתמקדת בפעולות, בעוד State מתמקדת במצבים</td>
                </tr>
                <tr>
                    <td>Observer</td>
                    <td>מתמקדת בהודעות, בעוד State מתמקדת במצבים</td>
                </tr>
                <tr>
                    <td>Memento</td>
                    <td>מתמקדת בשמירת מצב, בעוד State מתמקדת במצבים</td>
                </tr>
            </table>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-pencil-alt icon"></i>
                תרגול
            </h2>
            <h3>למתחילים:</h3>
            <p>נסה ליישם את תבנית State במקרים הבאים:</p>
            <ol>
                <li>מנורה עם מצבים שונים</li>
                <li>מערכת ניהול הזמנות</li>
                <li>מערכת ניהול מסמכים</li>
            </ol>

            <h3>למתקדמים:</h3>
            <p>נסה ליישם את תבנית State במקרים הבאים:</p>
            <ol>
                <li>מנורה</li>
                <li>מערכת ניהול משימות</li>
                <li>מערכת ניהול הזמנות</li>
                <li>מערכת ניהול מסמכים</li>
            </ol>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-lightbulb icon"></i>
                טיפים ליישום
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>השתמש בממשק פשוט ונוח לשימוש</li>
                <li>ודא שהאובייקטים מספקים את כל הפונקציונליות הנדרשת</li>
                <li>הוסף בדיקות תקינות לממשק הפשוט</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>השתמש בממשק פשוט ונוח לשימוש</li>
                <li>ודא שהאובייקטים מספקים את כל הפונקציונליות הנדרשת</li>
                <li>הוסף בדיקות תקינות לממשק הפשוט</li>
                <li>שקול שימוש ב-Dependency Injection</li>
                <li>השתמש ב-Interface Segregation Principle</li>
                <li>הוסף תיעוד מפורט לממשקים והמימושים</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-book icon"></i>
                מקרי שימוש נפוצים
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>מערכות ניהול משימות</li>
                <li>מערכות ניהול הזמנות</li>
                <li>מערכות ניהול מסמכים</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>מערכות ניהול משימות</li>
                <li>מערכות ניהול הזמנות</li>
                <li>מערכות ניהול מסמכים</li>
                <li>מערכות ניהול תהליכים</li>
                <li>מערכות ניהול מצבי מערכת</li>
            </ul>
        </section>

        <div class="related-patterns card">
            <h2 class="flex-center">
                <i class="fas fa-link icon"></i>
                תבניות קשורות
            </h2>
            <ul>
                <li><a href="strategy.html" class="flex-center"><i class="fas fa-cogs icon"></i>Strategy</a></li>
                <li><a href="command.html" class="flex-center"><i class="fas fa-terminal icon"></i>Command</a></li>
                <li><a href="observer.html" class="flex-center"><i class="fas fa-eye icon"></i>Observer</a></li>
                <li><a href="memento.html" class="flex-center"><i class="fas fa-history icon"></i>Memento</a></li>
            </ul>
        </div>
    </main>

    <script src="../js/load-sidebar.js"></script>
</body>
</html> 