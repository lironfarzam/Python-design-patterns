<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bridge Pattern - תבניות עיצוב בפייתון</title>
    <link rel="stylesheet" href="../css/styles.css">
 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Prism.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <!-- Prism.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <!-- Prism.js Python Language Support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script></head>
<body>
    <div class="side-nav-container">
        <nav class="side-nav">
            <!-- הסיידבר יוטען כאן באופן דינמי -->
        </nav>
    </div>

    <main class="main-content">
        <header class="rtl-container">
            <h1 class="flex-center">
                <i class="fas fa-bridge icon"></i>
                Bridge Pattern
            </h1>
            <a href="../index.html" class="flex-center">
                <i class="fas fa-arrow-right icon"></i>
                חזרה לדף הבית
            </a>
        </header>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-info-circle icon"></i>
                מהי תבנית Bridge?
            </h2>
            <p>תבנית Bridge היא תבנית עיצוב מבנית המפרידה בין ממשק למימוש. התבנית משמשת כאשר יש צורך להפריד בין הממשק של מחלקה למימוש שלה, כדי לאפשר שינוי עצמאי של שניהם.</p>
            
            <h3>הסבר למתחילים:</h3>
            <p>דמיינו שיש לכם רמקול עם אפשרות לחיבור ל-Bluetooth או USB. במקום ליצור רמקול נפרד לכל סוג חיבור, אפשר להשתמש בתבנית Bridge כדי להפריד בין הרמקול עצמו לבין סוג החיבור. כך אפשר להוסיף סוגי חיבור חדשים בלי לשנות את הרמקול.</p>
            
            <h3>הסבר למתקדמים:</h3>
            <p>התבנית מיישמת את עקרון ה-Bridge Pattern על ידי שימוש בממשק מופשט (Abstraction) ובמימוש מופשט (Implementor). זה מאפשר שינוי עצמאי של הממשק והמימוש, ומאפשר הוספת מימושים חדשים בלי לשנות את הממשק.</p>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-question-circle icon"></i>
                מתי להשתמש בתבנית?
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>כאשר אתם צריכים להפריד בין ממשק למימוש</li>
                <li>כאשר אתם צריכים לאפשר שינוי עצמאי של הממשק והמימוש</li>
                <li>כאשר אתם צריכים להוסיף מימושים חדשים בלי לשנות את הממשק</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>כאשר יש צורך להפריד בין ממשק למימוש</li>
                <li>כאשר יש צורך לאפשר שינוי עצמאי של הממשק והמימוש</li>
                <li>כאשר יש צורך להוסיף מימושים חדשים בלי לשנות את הממשק</li>
                <li>כאשר יש צורך לשמור על עקרון ה-Open/Closed Principle</li>
                <li>כאשר יש צורך לאפשר שימוש חוזר בקוד קיים</li>
                <li>כאשר יש צורך לאפשר שינוי ממשקים ללא שינוי הקוד הקיים</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-sitemap icon"></i>
                מבנה התבנית
            </h2>
            <h3>הסבר בסיסי:</h3>
            <p>התבנית מורכבת משני חלקים עיקריים:</p>
            <ul>
                <li><strong>Abstraction</strong> - הממשק המופשט</li>
                <li><strong>Implementor</strong> - המימוש המופשט</li>
            </ul>

            <h3>הסבר מתקדם:</h3>
            <p>התבנית מורכבת מהמרכיבים הבאים:</p>
            <ul>
                <li><strong>Abstraction</strong> - הממשק המופשט</li>
                <li><strong>RefinedAbstraction</strong> - הרחבה של הממשק המופשט</li>
                <li><strong>Implementor</strong> - המימוש המופשט</li>
                <li><strong>ConcreteImplementor</strong> - מימוש ספציפי</li>
            </ul>

            <h3>היחסים בין המרכיבים:</h3>
            <ul>
                <li>Abstraction משתמש ב-Implementor</li>
                <li>RefinedAbstraction מיישם את Abstraction</li>
                <li>ConcreteImplementor מיישם את Implementor</li>
                <li>Implementor מספק את הפונקציונליות הבסיסית</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-code icon"></i>
                דוגמה בסיסית
            </h2>
            <h3>הסבר למתחילים:</h3>
            <p>בדוגמה הבאה, אנחנו יוצרים מערכת לניהול צורות גיאומטריות. יש לנו צורות שונות (עיגול, ריבוע) וצבעים שונים (אדום, כחול). במקום ליצור מחלקה לכל שילוב, אנחנו משתמשים בתבנית Bridge כדי להפריד בין הצורה לצבע.</p>

            <h3>הסבר למתקדמים:</h3>
            <p>הדוגמה מדגימה את השימוש ב-Bridge Pattern ליצירת הפרדה בין צורה לצבע. הממשק המופשט מגדיר את הפעולות הבסיסיות, והמימושים הספציפיים מספקים את הפונקציונליות.</p>

            <pre><code class="language-python">from abc import ABC, abstractmethod

class Color(ABC):
    @abstractmethod
    def fill(self) -> str:
        pass

class RedColor(Color):
    def fill(self) -> str:
        return "אדום"

class BlueColor(Color):
    def fill(self) -> str:
        return "כחול"

class Shape(ABC):
    def __init__(self, color: Color):
        self.color = color
    
    @abstractmethod
    def draw(self) -> str:
        pass

class Circle(Shape):
    def draw(self) -> str:
        return f"ציירתי עיגול בצבע {self.color.fill()}"

class Square(Shape):
    def draw(self) -> str:
        return f"ציירתי ריבוע בצבע {self.color.fill()}"

# שימוש
if __name__ == "__main__":
    # יצירת צבעים
    red = RedColor()
    blue = BlueColor()
    
    # יצירת צורות
    red_circle = Circle(red)
    blue_square = Square(blue)
    
    # שימוש בצורות
    print(red_circle.draw())
    print(blue_square.draw())</code></pre>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-laptop-code icon"></i>
                דוגמה מעשית - מערכת הודעות
            </h2>
            <h3>הסבר למתחילים:</h3>
            <p>בדוגמה זו, אנחנו יוצרים מערכת הודעות שתומכת בסוגי הודעות שונים (טקסט, תמונה) ובפלטפורמות שונות (אימייל, SMS). במקום ליצור מחלקה לכל שילוב, אנחנו משתמשים בתבנית Bridge כדי להפריד בין סוג ההודעה לפלטפורמה.</p>

            <h3>הסבר למתקדמים:</h3>
            <p>הדוגמה מדגימה את השימוש ב-Bridge Pattern ליצירת הפרדה בין סוג הודעה לפלטפורמה. הממשק המופשט מגדיר את הפעולות הבסיסיות, והמימושים הספציפיים מספקים את הפונקציונליות.</p>

            <pre><code class="language-python">from abc import ABC, abstractmethod
from typing import Dict, Any

class Platform(ABC):
    @abstractmethod
    def send(self, content: str, recipient: str) -> bool:
        pass

class EmailPlatform(Platform):
    def send(self, content: str, recipient: str) -> bool:
        print(f"שולח אימייל ל-{recipient}: {content}")
        return True

class SMSPlatform(Platform):
    def send(self, content: str, recipient: str) -> bool:
        print(f"שולח SMS ל-{recipient}: {content}")
        return True

class Message(ABC):
    def __init__(self, platform: Platform):
        self.platform = platform
    
    @abstractmethod
    def send(self, recipient: str) -> bool:
        pass

class TextMessage(Message):
    def __init__(self, platform: Platform, text: str):
        super().__init__(platform)
        self.text = text
    
    def send(self, recipient: str) -> bool:
        return self.platform.send(self.text, recipient)

class ImageMessage(Message):
    def __init__(self, platform: Platform, image_url: str):
        super().__init__(platform)
        self.image_url = image_url
    
    def send(self, recipient: str) -> bool:
        return self.platform.send(f"תמונה: {self.image_url}", recipient)

# שימוש
if __name__ == "__main__":
    # יצירת פלטפורמות
    email = EmailPlatform()
    sms = SMSPlatform()
    
    # יצירת הודעות
    text_email = TextMessage(email, "שלום, זו הודעת טקסט")
    image_sms = ImageMessage(sms, "https://example.com/image.jpg")
    
    # שליחת הודעות
    text_email.send("user@example.com")
    image_sms.send("+1234567890")</code></pre>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-plus-circle icon"></i>
                יתרונות
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>מאפשרת הפרדה בין ממשק למימוש</li>
                <li>מאפשרת שינוי עצמאי של הממשק והמימוש</li>
                <li>מאפשרת הוספת מימושים חדשים בלי לשנות את הממשק</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>מאפשרת הפרדה בין ממשק למימוש</li>
                <li>מאפשרת שינוי עצמאי של הממשק והמימוש</li>
                <li>מאפשרת הוספת מימושים חדשים בלי לשנות את הממשק</li>
                <li>מאפשרת שמירה על עקרון ה-Open/Closed Principle</li>
                <li>מאפשרת שימוש חוזר בקוד קיים</li>
                <li>מאפשרת שינוי ממשקים ללא שינוי הקוד הקיים</li>
                <li>מאפשרת הפרדה בין הממשק למימוש</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-minus-circle icon"></i>
                חסרונות
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>עלולה להקשות על הבנת הקוד</li>
                <li>עלולה ליצור תלות בין המחלקות</li>
                <li>עלולה להקשות על ניהול הקוד</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>עלולה להקשות על הבנת הקוד</li>
                <li>עלולה ליצור תלות בין המחלקות</li>
                <li>עלולה להקשות על ניהול הקוד</li>
                <li>עלולה להקשות על בדיקות (Testing)</li>
                <li>עלולה להקשות על ניהול גרסאות</li>
                <li>עלולה להקשות על ניהול תלויות</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-exclamation-triangle icon"></i>
                מלכודות נפוצות
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>אי-הקפדה על הפרדה בין ממשק למימוש</li>
                <li>אי-הקפדה על שימוש נכון בממשק המופשט</li>
                <li>אי-הקפדה על ניהול תלויות</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>אי-הקפדה על הפרדה בין ממשק למימוש</li>
                <li>אי-הקפדה על שימוש נכון בממשק המופשט</li>
                <li>אי-הקפדה על ניהול תלויות</li>
                <li>אי-הקפדה על ניהול גרסאות</li>
                <li>אי-הקפדה על בדיקות (Testing)</li>
                <li>אי-הקפדה על ניהול זיכרון</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-balance-scale icon"></i>
                השוואה לתבניות אחרות
            </h2>
            <h3>למתחילים:</h3>
            <table>
                <tr>
                    <th>תבנית</th>
                    <th>הבדל</th>
                </tr>
                <tr>
                    <td>Adapter</td>
                    <td>מתמקדת בהתאמת ממשקים, בעוד Bridge מתמקדת בהפרדה בין ממשק למימוש</td>
                </tr>
                <tr>
                    <td>Decorator</td>
                    <td>מתמקדת בהוספת תכונות לאובייקט, בעוד Bridge מתמקדת בהפרדה בין ממשק למימוש</td>
                </tr>
            </table>

            <h3>למתקדמים:</h3>
            <table>
                <tr>
                    <th>תבנית</th>
                    <th>הבדל</th>
                </tr>
                <tr>
                    <td>Adapter</td>
                    <td>מתמקדת בהתאמת ממשקים, בעוד Bridge מתמקדת בהפרדה בין ממשק למימוש</td>
                </tr>
                <tr>
                    <td>Decorator</td>
                    <td>מתמקדת בהוספת תכונות לאובייקט, בעוד Bridge מתמקדת בהפרדה בין ממשק למימוש</td>
                </tr>
                <tr>
                    <td>Facade</td>
                    <td>מתמקדת בספק ממשק פשוט למערכת מורכבת, בעוד Bridge מתמקדת בהפרדה בין ממשק למימוש</td>
                </tr>
                <tr>
                    <td>Proxy</td>
                    <td>מתמקדת בשליטה בגישה לאובייקט, בעוד Bridge מתמקדת בהפרדה בין ממשק למימוש</td>
                </tr>
            </table>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-pencil-alt icon"></i>
                תרגול
            </h2>
            <h3>למתחילים:</h3>
            <p>נסה ליישם את תבנית Bridge במקרים הבאים:</p>
            <ol>
                <li>מערכת צורות גיאומטריות עם צבעים שונים</li>
                <li>מערכת הודעות עם פלטפורמות שונות</li>
                <li>מערכת תצוגה עם מכשירים שונים</li>
            </ol>

            <h3>למתקדמים:</h3>
            <p>נסה ליישם את תבנית Bridge במקרים הבאים:</p>
            <ol>
                <li>מערכת אחסון קבצים עם שירותי אחסון שונים</li>
                <li>מערכת דיווח עם פורמטים שונים</li>
                <li>מערכת תקשורת עם פרוטוקולים שונים</li>
                <li>מערכת עיבוד תמונות עם פורמטים שונים</li>
            </ol>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-lightbulb icon"></i>
                טיפים ליישום
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>השתמש בממשק מופשט ל-Abstraction</li>
                <li>ודא שה-Implementor מיישם את הממשק הנכון</li>
                <li>הוסף בדיקות תקינות ל-Abstraction ו-Implementor</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>השתמש בממשק מופשט ל-Abstraction</li>
                <li>ודא שה-Implementor מיישם את הממשק הנכון</li>
                <li>הוסף בדיקות תקינות ל-Abstraction ו-Implementor</li>
                <li>שקול שימוש ב-Dependency Injection</li>
                <li>השתמש ב-Interface Segregation Principle</li>
                <li>הוסף תיעוד מפורט לממשקים והמימושים</li>
            </ul>
        </section>

        <section class="card">
            <h2 class="flex-center">
                <i class="fas fa-book icon"></i>
                מקרי שימוש נפוצים
            </h2>
            <h3>למתחילים:</h3>
            <ul>
                <li>מערכות צורות גיאומטריות</li>
                <li>מערכות הודעות</li>
                <li>מערכות תצוגה</li>
            </ul>

            <h3>למתקדמים:</h3>
            <ul>
                <li>מערכות אחסון קבצים</li>
                <li>מערכות דיווח</li>
                <li>מערכות תקשורת</li>
                <li>מערכות עיבוד תמונות</li>
                <li>מערכות אחסון נתונים</li>
            </ul>
        </section>

        <div class="related-patterns card">
            <h2 class="flex-center">
                <i class="fas fa-link icon"></i>
                תבניות קשורות
            </h2>
            <ul>
                <li><a href="adapter.html" class="flex-center"><i class="fas fa-plug icon"></i>Adapter</a></li>
                <li><a href="decorator.html" class="flex-center"><i class="fas fa-paint-brush icon"></i>Decorator</a></li>
                <li><a href="facade.html" class="flex-center"><i class="fas fa-building icon"></i>Facade</a></li>
                <li><a href="proxy.html" class="flex-center"><i class="fas fa-shield-alt icon"></i>Proxy</a></li>
            </ul>
        </div>
    </main>

    <script src="../js/load-sidebar.js"></script>
</body>
</html> 